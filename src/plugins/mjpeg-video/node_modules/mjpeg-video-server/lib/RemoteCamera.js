const os            = require( "os" );
const Listener      = require( "Listener" );
const Promise       = require( "bluebird" );
const Respawn       = require( "respawn" );

const log           = require( "debug" )( "app:remotecamera:log" );
const error	    = require( "debug" )( "app:remotecamera:error" );

const dLog	    = require( "debug" )( "app:daemon:log" );
const dError	    = require( "debug" )( "app:daemon:error" );

class RemoteCamera
{
    constructor( serial, devicePath, wsPort, raspiCameraID, configuration )
    {
        // Camera properties
        this.serial     = serial;
        this.devicePath = devicePath;
        this.wsPort     = wsPort;
        this.cameraID   = raspiCameraID;
        this.cameraName = "camera" + raspiCameraID.toString();
        this.alive      = true;

        // Config
        this.sslInfo    = configuration.sslInfo;
        this.settings   = configuration.cameraSettings;
        this.sioServerRemote  = configuration.sioServerRemote;
        log( "Remote camera: this.sioServerRemote: " + this.sioServerRemote);
        this.sioServerLocal   = configuration.sioServerLocal;
        log( "Remote camera: this.sioServerLocal: " + this.sioServerLocal);
        this.eventBus   = configuration.eventBus;

        // Mock mode info
        this.useMock            = configuration.useMock;

        // Create process daemon
        this.daemon = Respawn( this.getDaemonCommand(),
        {
            name:           'remote-camera',
            env:            {LD_LIBRARY_PATH:'/usr/local/lib/mjpg-streamer:/usr/local/lib:/usr/lib'},
            maxRestarts:    5,
            sleep:          5000
        });

        this.listeners =
        {
            registration: new Listener( this.eventBus, "broadcastRegistration", false, () =>
            {
                if( this.alive === true )
                {
                    var thisIP = this.getExternalIp();
                    // get the last number group
                    var index = this.getPosition(thisIP,".",3);
                    // get the value of that last number group
                    var id = thisIP.substring(index+1);
                    var baseIP = thisIP.substring(0,index+1);
                    // change a string to an integer
                    var value = parseInt(id);
                    // add one
                    value = value+1;
                    // now build a new IP address
                    var newIP = "http://" + baseIP + value.toString() + ":"; 
                    log( "Sending registration: Remote camera: " + this.cameraName + "new IP: " + newIP + " port: " + this.wsPort);
                    // var newIP = "http://192.168.1.22:";
                    log( "Sending registration: Remote camera: " + this.cameraName + "new IP: " + newIP + " port: " + this.wsPort);
                    // Send registration message
                    this.sioServerLocal.emit( "stream.registration", this.serial,
                    {
                        relativeServiceUrl:     newIP + this.wsPort,
                        port:                   this.wsPort,
                        resolution:             this.settings.resolution,
                        framerate:              this.settings.framerate,
                        connectionType:       ( this.useMock ? "ws" : "ws" ),
                        cameraName:             this.cameraName,
                        cameraID:               this.cameraID
                    });
                }
            }),

            settings: new Listener( this.eventBus, "updateSettings", false, ( settings ) =>
            {
                log( "Received remote camera settings update" );

                this.settings = settings;

                // Restart camera
                this.restart()
                    .catch( (err) =>
                    {
                        error( `Error restarting remote camera: ${err.message}` );
                    });
            })
        }

        this.listeners.registration.enable();
        this.listeners.settings.enable();

        // Promisify start and stop
        this.daemon.startAsync  = Promise.promisify( this.daemon.start );
        this.daemon.stopAsync   = Promise.promisify( this.daemon.stop );

        // Set up daemon listeners
        this.daemon.on( "crash", () =>
        {
            dError( "Remote Camera crashed too many times. Disabling." );

            // Camera has crashed too many times. Kill it.
            this.kill();
        });

        this.daemon.on( "stderr", (data) =>
        {
            dError( data.toString() );
        });

        if (this.sioServerRemote != null) {
            log("sioRemote Server local: " + this.sioServerRemote.localAddress + ":" + this.sioServerRemote.localPort);
            log("sioRemote Server remote: " + this.sioServerRemote.remoteAddress + ":" + this.sioServerRemote.remotePort);
            // this.sioServerRemote.onmessage = function(buffer)
            // {
            //     log("get remote data: " + buffer);
            // };
            // this.sioServerRemote.onclose = function(buffer)
            // {
            //     log("close remote data: " + buffer);
            // };
            // this.sioServerRemote.onclose = function(buffer)
            // {
            //     log("end remote data");
            // };
            // this.sioServerRemote.onerror = function(buffer)
            // {
            //     log("error remote data: " + buffer);
            // };
        }

    };

    getExternalIp()
    {
        var ifconfig = os.networkInterfaces();
        var device, i, I, protocol;

        for (device in ifconfig) {
            // ignore loopback interface
            if (device.indexOf('lo') !== -1 || !ifconfig.hasOwnProperty(device)) {
                continue;
            }

            for (i = 0, I=ifconfig[device].length; i < I; i++) {
                protocol = ifconfig[device][i];
                // filter for external IPv4 addresses
                if (protocol.family === 'IPv4' && protocol.internal === false) {
                   return protocol.address;
                }
            }
        }
    }

    getPosition(string, subString, index)
    {
        return string.split(subString, index).join(subString).length;
    }


    getDaemonCommand()
    {
        // This just needs to be a running process to fake teh system into thinking the camera is running
        // it would be better if it pinged the socket and made sure it was still alive
        return [
            "nice", "--19",
            "remotecamera.sh"
        ];
    }

    start()
    {
        log( "Starting remote camera daemon" );
        this.daemon.command = this.getDaemonCommand();
        log( `Daemon command: ${this.daemon.command}` );
        return this.daemon.startAsync();
    }

    stop()
    {
        log( "Stopping remote camera daemon" );
        return this.daemon.stopAsync();
    }

    restart()
    {
        log( "Restarting remote camera daemon" );
        return this.stop()
                .then( () =>
                {
                    // Update the daemon command, in case settings changed
                    this.daemon.command = this.getDaemonCommand();
                    log( `Daemon command: ${this.daemon.command}` );
                })
                .then( () =>
                {
                    return this.start();
                });
    }

    kill()
    {
        log(`Killing remote camera ${this.cameraID}`);
        this.alive = false;
    }
};

module.exports = RemoteCamera;
