// Dependencies
const os            = require( "os" );
const net           = require( "net" );
const Promise       = require( "bluebird" );
const path	    = require( "path" );
const execFileAsync = require( 'child-process-promise' ).execFile;
const http          = require( "http" );
const SIOServer     = require( "socket.io" );
const ObjectPool    = require( "ObjectPool" );
const Periodic      = require( "Periodic" );
const EventEmitter  = require( "eventemitter3" );
const fs 	    = Promise.promisifyAll( require( "fs" ) );

// Logging utilities
const log           = require( "debug" )( "app:supervisor:log" );
const error	    = require( "debug" )( "app:supervisor:error" );

const Camera        = require( "Camera" );
const RemoteCamera  = require( "RemoteCamera" );
const MockCamera    = require( "MockCamera" );
const maxCameras    = 4;

class Supervisor
{
    constructor( settings )
    {
        // Initialize properties
        this.settings   = settings;
        this.httpAServer = null;
        this.httpB0Socket = null;
        this.httpB1Socket = null;
        this.sioAServer  = null;
        this.sioAListener  = null;
        this.sioB0Socket  = null;
        this.sioB1Socket  = null;
        this.sioB0Listener  = null;
        this.sioB1Listener  = null;
        this.eventBus   = new EventEmitter();
        this.cameras    = {};
        this.isScanning = false;
        this.serialNo   = 0;
        this.runVideo0  = true;
        this.runVideo1  = true;
        this.scanPending = false;
        this.cleanupPending = false;

        this.sslInfo    = 
        {
            certPath: this.settings.cert,
            keyPath: this.settings.key
        }

        this.defaultCamSettings =
        {
            framerate:  30,
            resolution: "1280x720"
        }

        // Create a pool of ports for the cameras to start daemons on
        // let wsPort          = 8200;
        let wsPort          = 8090;
        this.portPool       = new ObjectPool( { maxSize: maxCameras, initialSize: maxCameras }, () =>
        {
            // Create port and increment counter
            return wsPort++;
        });

        this.periodics = 
        {
            cameraCleanup: new Periodic( 5000, "timeout", () =>
            {
                // don't do a cleanup while scanning is underway
                if ((this.scanPending === false) && (this.isScanning === false)) {
                    log( `Camera cleanup` );
                    this.cleanupPending = true;
                    for( var serial in this.cameras )
                    {
                        if( this.cameras[ serial ] !== undefined && this.cameras[ serial ].alive === false )
                        {
                            return Promise.try( () =>
                            {
                                log( `Removing camera ${serial}` );
                                this.removeCamera( serial );
                            })
                            .catch( (err) =>
                            {
                                error( `Error removing camera: ${err.message}`);
                            })
                        }
                    }
                    this.cleanupPending = false;
                }
            }),

            broadcastRegistrations: new Periodic( 5000, "timeout", () =>
            {
                this.broadcastCameraRegistrations();
            })
        }
    }

    run()
    {

        var PaddRemoteListener = Promise.promisify(this.addRemoteListener);
        var PaddRemoteConnection = Promise.promisify(this.addRemoteConnection);
        var PaddRemoteCameras = Promise.promisify(this.addRemoteCameras);

        // Create HTTP server for the local cameras
        this.httpAServer = http.createServer();

        // Start listening locally on specified port
        log( "Listener for RPi A" );
        // listen to the supervisor?
        // was: this.settings.port 
        // Create Socket.IO server for RPiA (local)
        this.sioAServer = SIOServer( this.httpAServer, { origins: '*:*', path: "/mjpeg" } );
        // move listener from httpAServer to sioAServer
        log( "sioAServer created" );
        this.sioAListener = this.sioAServer.listen(this.httpAServer);
        log( "sioAServerListener on httpAServer" );
        this.httpAServer.listen( 8090, () =>
        {
            log( "HTTP A Server listening on port: " + this.settings.port );
        });


        // Create HTTP server for the remote cameras (on the other RPi)
        // create a socket to connect to RPiB
        // AF_INET, SOCK_STREAM, default_protocol
        // bind the socket to the server we want to listed to (RPiB)
        // AF_INET (sin_family), RPiB IP, PORT
        // listen on that socket
        // if (this.httpB0Socket == null) {
        //      log( "net.createConnection for RPi B camera 0" );
        //      this.httpB0Socket = net.createConnection( '8091', this.settings.RPiBName, () => {
        //          log( "HTTP B Camera 0 Server listening on port 8091 ");
        //          // Create Socket.IO server for RPiB (remote)
        //          this.sioB0Socket = SIOServer( this.httpB0Socket, { origins: '*:*', path: "/mjpeg" } );
        //          log( "this.sioB0Socket: " + this.sioB0Socket);
        //          this.sioB0Listener = this.sioB0Socket.listen(this.httpB0Socket);
        //          log( "this.sioB0Listener: " + this.sioB0Listener);
        //      }).on('error', (err) => {
        //          log( "HTTP B Camera 0 Server cannot listen on port 8091 ");
        //      });
        // }
        // if (this.httpB1Socket == null) {
        //     log( "net.createConnection for RPi B camera 1" );
        //     this.httpB1Socket = net.createConnection( '8092', this.settings.RPiBName, () => {
        //          log( "HTTP B Camera 1 Server listening on port 8092 ");
        //          // Create Socket.IO server for RPiB (remote)
        //          this.sioB1Socket = SIOServer( this.httpB1Socket, { origins: '*:*', path: "/mjpeg" } );
        //          this.sioB1Listener = this.sioB1Socket.listen(this.httpB1Socket);
        //        }).on('error', (err) => {
        //          log( "HTTP B Camera 1 Server cannot listen on port 8092 ");
        //        });
        // }

        // Perform initial camera scan for local cameras
        // Then add remote cameras (assume they are there)
        var hostname = os.hostname();
        if (hostname.indexOf("B") === -1) {
           PaddRemoteConnection(this,'8091').then(PaddRemoteListener(this,'8091')).then(PaddRemoteConnection(this,'8092')).then(PaddRemoteListener(this,'8092')).then(this.scanForCameras(this.runVideo0,this.runVideo1));
        } else {
           this.scanForCameras(this.runVideo0,this.runVideo1);
        }
        // this.addRemoteConnection(this, '8091').then(this.addRemoteConnection(this, '8092')).then(this.scanForCameras()).then(this.addRemoteCameras(this)).then(this.addRemoteListener(this,'8091')).then(this.addRemoteListener(this,'8092'));
        // PaddRemoteConnection.call(this, this, '8091').then(PaddRemoteConnection.call(this, this, '8092')).then(PaddRemoteListener.call(this, this,'8091')).then(PaddRemoteListener.call(this, this,'8092')).then(this.scanForCameras()).then(PaddRemoteCameras.call(this, this));

        // this addRemoteConnection(this, '8091').then(function() {
        //                                             this.addRemoteConnection(this, '8092')
        //                                      }).then(function() {
        //                                             this.scanForCameras()
        //                                      }).then(function() {
        //                                             this.addRemoteCameras(this)
        //                                      }).then(function() {
        //                                             this.addRemoteListener(this,'8091')
        //                                      }).then(function() {
        //                                             this.addRemoteListener(this,'8092')
        //                                      });
        // reset the serial number after each scan
        // this.serialNo = 0;

        // if (this.sioB0Listener !== null) {
        //     log( "New B0 listener!" );
        //     this.sioB0Listener.on( "connection", client =>
        //     {
        //         log( "New remote B0 supervisor connection!" );
        //         client.on( "updateSettings", ( settings ) =>
        //         {
        //             log( "remote updateSettings!" );
        //         });

        //         client.on( "scan", () =>
        //         {
        //             log( "remote scan!" );
        //         });

        //         client.on( "sendRegistrations", () =>
        //         {
        //             log( "remote sendRegistrations!" );
        //         });
        //     });
        //     this.httpB0Socket.listen(8091);
        // }

        // if (this.sioB1Listener !== null) {
        //     log( "New B1 listener!" );
        //     this.sioB1Listener.on( "connection", client =>
        //     {
        //         log( "New remote B1 supervisor connection!" );
        //         client.on( "updateSettings", ( settings ) =>
        //         {
        //             log( "remote updateSettings!" );
        //         });

        //         client.on( "scan", () =>
        //         {
        //             log( "remote scan!" );
        //         });

        //         client.on( "sendRegistrations", () =>
        //         {
        //             log( "remote sendRegistrations!" );
        //         });
        //     });
        //     this.httpB1Socket.listen(8092);
        // }

        // Start handling connections
//        this.sioAServer.on( "connection", client => 
        this.sioAListener.on( "connection", client => 
        {
            log( "New mjpeg supervisor sioAServer connection!" );

            // -----------------------
            // Public API

            client.on( "updateSettings", ( settings ) =>
            {
                log( "updateSettings sioAServer" );
                // For now, update defaults and send to all cameras
                this.defaultCamSettings = settings;

                log( settings );

                // Send settings update event
                this.eventBus.emit( "updateSettings", this.defaultCamSettings );
            });

            client.on( "scan", function(runVideo0, runVideo1)
            {
                log( "Scanning sioAServer " + this.cameras );
                if (this.cleanupPending === true) {
                    log( "cleanup pending" );
                    return;
                }
                // make sure there's something to do
                if ((this.runVideo0 === runVideo0) && (this.runVideo1 === runVideo1)) {
                   return;
                }
                // don't do camera cleanup while scan in progress
                this.periodics.cameraCleanup.stop();
                // guard against pending operations
                if ((this.scanPending === false) && (this.isScanning === false)) {
                   this.scanPending = true;
                   for( var serial in this.cameras )
                   {
                       if( this.cameras[ serial ] !== undefined && this.cameras[ serial ].alive === true )
                       {
                            log( `Removing camera during scan ${serial}` );
                            this.removeCamera( serial );
                       }
                   }
                   // reset the serial number after each scan
                   this.serialNo = 0;
                   this.scanForCameras(runVideo0,runVideo1);
                   this.scanPending = false;
               }
               this.periodics.cameraCleanup.start();
            }.bind(this));

            client.on( "sendRegistrations", () =>
            {
                log( "sendRegistrations sioAServer" );
                this.broadcastCameraRegistrations();
            });
        });        

        // Start periodic functions
        this.periodics.cameraCleanup.start();
        this.periodics.broadcastRegistrations.start();

    }

    addRemoteListener(that, port)
    {
             log( "(X) that.sioB0Listener: " + that.sioB0Listener);
             log( "(X) that.sioB1Listener: " + that.sioB1Listener);
             if (port == '8091') {
                if (that.sioB0Listener !== null) {
                   log( "New B0 listener!" );
                   that.sioB0Listener.on( "connection", client =>
                   {
                       log( "New remote B0 supervisor connection!" );
                       client.on( "updateSettings", ( settings ) =>
                       {
                           log( "remote updateSettings!" );
                       });

                       client.on( "scan", function(runVideo0, runVideo1)
                       {
                           log( "remote scan!" );
                       });

                       client.on( "sendRegistrations", () =>
                       {
                           log( "remote sendRegistrations!" );
                       });
                   });
               } 
             } else {
               if (port == '8092') {
                  if (that.sioB1Listener !== null) {
                      log( "New B1 listener!" );
                      that.sioB1Listener.on( "connection", client =>
                      {
                          log( "New remote B1 supervisor connection!" );
                          client.on( "updateSettings", ( settings ) =>
                          {
                              log( "remote updateSettings!" );
                          });

                          client.on( "scan", function(runVideo0, runVideo1)
                          {
                              log( "remote scan!" );
                          });

                          client.on( "sendRegistrations", () =>
                          {
                              log( "remote sendRegistrations!" );
                          });
                      });
                  }
               }
             }
    }

    addRemoteConnection(that, port)
    {
             var thisIP = that.getExternalIp();
             // get the last number group
             var index = that.getPosition(thisIP,".",3);
             // get the value of that last number group
             var id = thisIP.substring(index+1);
             var baseIP = thisIP.substring(0,index+1);
             // change a string to an integer
             var value = parseInt(id);
             // add one
             value = value+1;
             // now build a new IP address
             var newIP = baseIP + value.toString();
             // now build a new IP address
             log( "HTTP B Camera IP: " + newIP);
             if (port == '8091') {
                 if (that.httpB0Socket == null) {
                      log( "net.createConnection for RPi B camera 0" );
//                      that.httpB0Socket = net.createConnection( '8091', that.settings.RPiBName, {readable : true, writable : true}, () => {
                      that.httpB0Socket = net.createConnection( '8091', newIP, {readable : true, writable : true}, () => {
                          log( "HTTP B Camera 0 Server listening on port 8091 ");
                          // Create Socket.IO server for RPiB (remote)
                          that.sioB0Socket = SIOServer( that.httpB0Socket, { origins: '*:*', path: "/mjpeg" } );
                          log( "that.sioB0Socket: " + that.sioB0Socket);
                          that.sioB0Socket.on('listen', () => {
                             log( "HTTP B Camera 0 socket listening on port 8091 ");
                          });
                          that.sioB0Listener = that.sioB0Socket.listen(that.httpB0Socket);
                          log( "that.sioB0Listener: " + that.sioB0Listener);
                          that.addRemoteCamera(that,"/dev/video0");
                      }).on('error', (err) => {
                          log( "HTTP B Camera 0 Server cannot listen on port 8091 of " + newIP);
                      });
                 }
             } else {
                  if (port == '8092') {
                      if (that.httpB1Socket == null) {
                          log( "net.createConnection for RPi B camera 1" );
//                          that.httpB1Socket = net.createConnection( '8092', that.settings.RPiBName, {readable : true, writable : true}, () => {
                          that.httpB1Socket = net.createConnection( '8092', newIP, {readable : true, writable : true}, () => {
                               log( "HTTP B Camera 1 Server listening on port 8092 ");
                               // Create Socket.IO server for RPiB (remote)
                               that.sioB1Socket = SIOServer( that.httpB1Socket, { origins: '*:*', path: "/mjpeg" } );
                               that.sioB1Listener = that.sioB1Socket.listen(that.httpB1Socket);
                               that.addRemoteCamera(that,"/dev/video1");
                          }).on('error', (err) => {
                               log( "HTTP B Camera 1 Server cannot listen on port 8092 of " + newIP);
                          });
                      }
                  }
             }
    }

    // this routine assumes that RPiB is alive and has cameras connected
    // so it will instantiate the Camera object and start listening for
    // its image data. We use a unique serial number and 'fake' path
    // to fool the system into treating the RPiB cameras like local ones
    addRemoteCameras(that)
    {
            that.serialNo = that.serialNo + 1;
            log( `Creating remote camera ${that.serialNo}` );
            // use a 'fake' device path to create a unique cameraID
            that.createRemoteCamera( that.serialNo, "/dev/video0" );
            that.serialNo = that.serialNo + 1;
            log( `Creating remote camera ${that.serialNo}` );
            // use a 'fake' device path to create a unique cameraID
            that.createRemoteCamera( that.serialNo, "/dev/video1" );
    }

    addRemoteCamera(that,path)
    {
            that.serialNo = that.serialNo + 1;
            log( `Creating remote camera ${that.serialNo}` );
            // use a 'fake' device path to create a unique cameraID
            that.createRemoteCamera( that.serialNo, path );
    }

    // Search for new V4L devices with MJPEG support
    scanForCameras(runVideo0,runVideo1)
    {
        log("scanForCameras: runVideo0: ", runVideo0, "runVideo1: ", runVideo1 );
        log( "(Y) this.sioB0Listener: " + this.sioB0Listener);
        log( "(Y) this.sioB1Listener: " + this.sioB1Listener);
        this.runVideo0 = runVideo0;
        this.runVideo1 = runVideo1;
        // Don't scan if already scanning
        if( this.isScanning === true )
        {
            return Promise.try( () =>
            {
                return;
            });
        }
        else
        {
            this.isScanning = true;

            return Promise.try( () =>
            {
                if( this.settings.useMock === true && this.settings.useHardware === false )
                {
                    // Create and start the mock camera
                    return Promise.try( () =>
                        {
                            log( `Creating Mock Camera` );
                            this.createMockCamera();
                        })
                        .catch( (err) =>
                        {
                            error( `Error creating Mock Camera: ${err.message}` );
                        })
                }
                else
                {
                    return execFileAsync( "v4l2-ctl", [ "--list-devices" ] )
                    .then( ( results ) =>
                    {
                        // Return list of V4L capable video device files
                        return results.stdout.replace( /\t/g, '', "" )      // Trim away tabs
                            .split( "\n" )                                  // Split by lines
                            .filter( ( line ) => 
                            { 
                                // Return only the /dev/* lines
                                return ( line.indexOf( "/dev/" ) !== -1 ) 
                            } );
                    })
                    .then( (deviceFiles) =>
                    {
                        // Filter on MJPG capable cameras
                        return Promise.filter( deviceFiles, (deviceFile) =>
                        {
                            // List camera's supported formats
                            return execFileAsync( "v4l2-ctl", [ "--list-formats", "-d", deviceFile ] )
                                .then( (result) =>
                                {
                                    // Return true if MJPG is a present format
                                    return ( result.stdout.indexOf( "MJPG" ) !== -1 );
                                })
                                .catch( (err) =>
                                {
                                    // Somehow this camera failed to provide a format using v4l2-ctl. Skip it.
                                    error( `Error fetching formats for ${deviceFile}: ${err.message}`)
                                    return false;
                                });
                        });
                    })
                    .then( ( mjpgDevices ) =>
                    {
                        // Create new cameras for devices with valid serial numbers
                        return Promise.map( mjpgDevices, ( device ) =>
                        {
                            // Get device info
                            return execFileAsync( "udevadm", [ "info", "-a", "-n", device ] )
                                .then( ( results ) => 
                                {
                                    // Parse serial number from results
                                    this.serialNo = this.serialNo + 1;
                                    return {    serial: this.serialNo,
                                                device: device,
                                                runVideo0: runVideo0,
                                                runVideo1: runVideo1 }
//                                    return {    serial: results.stdout.match( /{serial}=="(.*)"/)[1],
//                                                device: device }
                                })
                                .catch( (err) =>
                                {
                                    // Skip
                                    error( `Could not find serial number for camera[${device}]: ${err.message}` );
                                });
                        })
                        .map( (cameraInfo) =>
                        {
                            return Promise.try( () =>
                            {
                                log( `Creating scanned camera ${cameraInfo.serial}` );
                                this.createCamera( cameraInfo.serial, cameraInfo.device, cameraInfo.runVideo0, cameraInfo.runVideo1 );
                            })
                            .catch( (err) =>
                            {
                                error( `Error creating scanned camera: ${err.message}` );
                            });
                        });     
                    })
                    .catch( (err) =>
                    {
                        log( "No V4L cameras found." );
                    })
                }
            })
            .catch( (err) =>
            {
                error( `Strange error in scan: ${err.message}` );
            })
            .then( () =>
            {
                // Mark as no longer scanning
                this.isScanning = false;
            });
        }
    }

    createCamera( serial, devicePath, runVideo0, runVideo1 )
    {
        log( `createCamera: serial: `, serial );
        if( this.cameras[ serial ] !== undefined )
        {
            throw new Error( "Camera already exists" );
        }

        log( `createCamera: camera devicePath: `, devicePath );
        var cameraIDStr = devicePath.substring((devicePath.length-1));

        // For now: set cameraID to zero
        let cameraID = parseInt(cameraIDStr);
        log( `createCamera: cameraID: `, cameraID );

        // Request a port
        let port = 8091 + cameraID;
        log( `createCamera: camera port: `, port );

        log( `createCamera: eventBus: `, this.eventBus );

        if( port )
        {
            // Create the camera
            this.cameras[ serial ] = new Camera( serial, devicePath, port, cameraID,
            {
                sslInfo:            this.sslInfo,
                cameraSettings:     this.defaultCamSettings,
                // sioServer:          ((cameraID < 2) ? this.sioAServer : this.sioBServer),
                sioServerLocal:     this.sioAServer,
                sioServerRemote:    this.httpB0Socket,
                eventBus:           this.eventBus,
                useMock:            ( this.settings.useMock === true && this.settings.useHardware === true ),
                runVideo:           (cameraID === 0 ? runVideo0 : runVideo1)
            } );

            // Start the local cameras only
            // The remote cameras have already started
            // if (cameraID < 2) {
               return this.cameras[ serial ].start();
            // }
        }
        else
        {
            throw new Error( "Could not create camera. Limit reached." );
        }
    }

    createRemoteCamera( serial, devicePath, sioBServer )
    {
        log( `createRemoteCamera: serial: `, serial );
        if( this.cameras[ serial ] !== undefined )
        {
            throw new Error( "Camera already exists" );
        }

        log( `createRemoteCamera: camera devicePath: `, devicePath );
        var cameraIDStr = devicePath.substring((devicePath.length-1));

        // For now: set cameraID to zero
        let cameraID = parseInt(cameraIDStr);
        log( `createCamera: cameraID: `, cameraID );

        // Request a port
        let port = 8091 + cameraID;
        log( `createRemoteCamera: camera port: `, port );

        log( `createRemoteCamera: eventBus: `, this.eventBus );

        if( port )
        {
            // Here I need to make something that takes an input frame 
            // from sioB0Socket or sioB1Socket (sioBServer) 
            // and sends it to 'port' on sioAServer. 
            // So it acts like a camera but is only a pipe
            // It has to register its stream like a camera
            // and deliver frames like a camera
            var sioServerRemote = null;
            if (port === 8091) {
                sioServerRemote = this.httpB0Socket;
            } else {
                sioServerRemote = this.httpB1Socket;
            }
            this.cameras[ serial ] = new RemoteCamera( serial, devicePath, port, cameraID,
            {
                sslInfo:            this.sslInfo,
                cameraSettings:     this.defaultCamSettings,
                sioServerLocal:     this.sioAServer,
                sioServerRemote:    sioServerRemote,
                eventBus:           this.eventBus,
                useMock:            ( this.settings.useMock === true && this.settings.useHardware === true ),
            } );

            return this.cameras[ serial ].start();
        }
        else
        {
            throw new Error( "Could not create camera. Limit reached." );
        }
    }

    createMockCamera()
    {
        let serial = "MOCK_SERIAL";

        if( this.cameras[ serial ] !== undefined )
        {
            throw new Error( "Mock camera already exists" );
        }

        // Request a port
        let port = this.portPool.request();
        log( `mock camera port ${port}` );

        if( port )
        {
            // Create the camera
            this.cameras[ serial ] = new MockCamera( serial, port, 
            {
                sioServerLocal:     this.sioAServer,
                eventBus:           this.eventBus
            } );

            // Start the camera
            return this.cameras[ serial ].start();
        }
        else
        {
            throw new Error( "Could not create Mock Camera. Limit reached." );
        }
    }

    removeCamera( serial )
    {
        // Stop the camera
        return this.cameras[ serial ].stop()
            .then( ()=>
            {
                // Recycle port number
                this.portPool.recycle( this.cameras[ serial ].wsPort );

                // Remove from camera list (leaves the serial key, but deletes the structure)
                this.cameras[ serial ] = undefined;
            });

        // TODO: Unregistration?
    }

    // Broadcast camera information to all clients
    broadcastCameraRegistrations()
    {
        this.eventBus.emit( "broadcastRegistration" );
    }

    getExternalIp()
    {
        var ifconfig = os.networkInterfaces();
        var device, i, I, protocol;

        for (device in ifconfig) {
            // ignore loopback interface
            if (device.indexOf('lo') !== -1 || !ifconfig.hasOwnProperty(device)) {
                continue;
            }

            for (i = 0, I=ifconfig[device].length; i < I; i++) {
                protocol = ifconfig[device][i];
                // filter for external IPv4 addresses
                if (protocol.family === 'IPv4' && protocol.internal === false) {
                   return protocol.address;
                }
            }
        }
    }

    getPosition(string, subString, index)
    {
        return string.split(subString, index).join(subString).length;
    }

}

module.exports = Supervisor;
